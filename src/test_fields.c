/* -------------------------------------------------------------------------- *
 *									      *
 *  test_fields.c							      *
 *                                                                            *
 *  testing for the calculation of 2D derivatives and convolutions	      *
 *                                                                            *
 *                                                                            *
 * -------------------------------------------------------------------------- */

// Last modified: Wed 30 Sep 15:47:30 2015

/* Program Description:
 *
 * This program is written to work with a python setup program. The setup
 * program will output some test vectors, on which this program performs some
 * operations. The python program will then check that the output of this code
 * is consistent with that of fields_2D.py.
 * 
 * Functions required:
 *
 * dy - returns y derivative of field
 *
 * dx - returns x derivative of a field
 *
 * to_physical - transforms from fully spectral to real space on the GL +
 *		 uniform grid
 *
 * to_spectral - transforms from physical space to fully spectral Chebyshev +
 *		 Fourier space.
 *
 * load_operators - loads the spectral operators from a text file generated in
 *		    python.
 *
 * save_state - saves the flow at the current time to a text file
 *
 * load_state - load the flow from a previous time from a text file.
 *
 * Plenty of other functions would be useful, but these are the essential ones.
 *
 * Unit Testing:
 *
 * Testing will be performed by comparing fields with those generated by python.
 *
 */

// Headers

#include"fields_IO.h"
#include"fields_2D.h"

// Main

int main() 
{
    flow_params params;

    params.N = 5;
    params.M = 100;
    params.U0 = 0;
    params.kx = 1.31;
    params.Re = 400;
    params.Wi = 1e-05;
    params.beta = 1.0;
    params.dealiasing = 1.0;

    if (params.dealiasing)
    {
	params.Nf = (3*params.N)/2 +1 ;
	params.Mf = (3*params.M)/2;
    } else
    {
	params.Nf = params.N;
	params.Mf = params.M;
    }

    // Declare variables

    int i=0;
    int j=0;
    int N = params.N;
    int M = params.M;
    int Nf = params.Nf;
    int Mf = params.Mf;

    flow_scratch scr;

    fftw_plan phys_plan, spec_plan;
    char infn[20] = "initial.h5";

    int shapefft = (2*Mf-2)*(2*Nf+1);

    //dynamically malloc array of complex numbers.
    fftw_complex* arrin = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    fftw_complex* specout = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    fftw_complex* specout2 = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    fftw_complex* derivout = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    fftw_complex* scratch = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));

    double* physout = (double*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(double));
    double* physout2 = (double*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(double));
    double* phystest = (double*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(double));

    // flow scratch space for the field calculations
    scr.scratch = (complex_d*) fftw_malloc(M*(N+1) * sizeof(complex_d));
    scr.scratch2 = (complex_d*) fftw_malloc(M*(N+1) * sizeof(complex_d));
    scr.scratch3 = (complex_d*) fftw_malloc(M*(N+1) * sizeof(complex_d));
    scr.scratch4 = (complex_d*) fftw_malloc(M*(N+1) * sizeof(complex_d));
    scr.scratchin = (fftw_complex*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(fftw_complex));
    scr.scratchout = (fftw_complex*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(fftw_complex));

    scr.scratchp1 = (double*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(double));
    scr.scratchp2 = (double*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(double));

    //Set up some dft plans
    phys_plan = fftw_plan_dft_2d(2*Nf+1, 2*Mf-2,  scr.scratchin, scr.scratchout,
			 FFTW_BACKWARD, FFTW_ESTIMATE);
    spec_plan = fftw_plan_dft_2d(2*Nf+1, 2*Mf-2,  scr.scratchin, scr.scratchout,
			 FFTW_FORWARD, FFTW_ESTIMATE);
    scr.phys_plan = &phys_plan;
    scr.spec_plan = &spec_plan;


    load_hdf5_state(infn, arrin, params);

    save_hdf5_state("testSpec.h5", arrin, params);

    printf("check the index function works correctly\n");
    if ((M*2 + 10) == (ind(2,10)))
    {
	printf("True\n");
    } else
    {
	printf("False\n");
    }

    // check derivatives

    dx(arrin, derivout, params);
    
    save_hdf5_state("testdx.h5", derivout, params);

    dy(arrin, derivout, params);
    save_hdf5_state("testdy.h5", derivout, params);

    dy(derivout, scratch, params);
    dy(scratch, derivout, params);
    dy(derivout, scratch, params);
    save_hdf5_state("testd4y.h5", scratch, params);

    // test transform to physical space 
    to_physical_r(arrin, physout, scr, params);
    save_hdf5_real_arr("testPhysicalT.h5", physout, shapefft);

    // test transform to spectral space
    to_spectral_r(physout, specout, scr, params);
    save_hdf5_state("testSpectralT.h5", specout, params);

    // Test a convolution
    fft_convolve_r(arrin, arrin, specout, scr, params);

    save_hdf5_state("fft_convolve.h5", specout, params);

    // Test transforms from physical space array
    for (i=0; i<2*Nf+1; i++)
    {
	for (j=0; j<Mf; j++)
	{
	    phystest[indfft(i,j)] = cos(i*M_PI/(2.*Nf)) * tanh(j*M_PI/(Mf-1.));
	    
	}
    }

    to_spectral_r(phystest, specout2, scr, params);
    save_hdf5_real_arr("phystest2.h5", phystest, shapefft);
    save_hdf5_state("testSpectralT2.h5", specout2, params);

    to_physical_r(specout2, physout, scr, params);
    save_hdf5_real_arr("testPhysT4.h5", physout, shapefft);


    //Test repeated spectral transforms
    for (i=0; i<100; i++)
    {
	to_physical_r(arrin, physout, scr, params);

	to_spectral_r(physout, arrin, scr, params);
     }

    save_hdf5_state("testSpectralTR.h5", arrin, params);

    //garbage collection
    fftw_destroy_plan(phys_plan);
    fftw_destroy_plan(spec_plan);
    fftw_free(arrin);
    fftw_free(derivout);
    fftw_free(specout);
    fftw_free(specout2);
    fftw_free(scratch);

    free(physout);
    free(physout2);
    free(phystest);

    fftw_free(scr.scratch);
    fftw_free(scr.scratch2);
    fftw_free(scr.scratch3);
    fftw_free(scr.scratch4);
    fftw_free(scr.scratchin); 
    fftw_free(scr.scratchout);
    fftw_free(scr.scratchp1);
    fftw_free(scr.scratchp2);

    return 0;
}
