/* -------------------------------------------------------------------------- *
 *									      *
 *  DNS_2D_Newt.c							      *
 *                                                                            *
 *  Time stepping DNS program for 2D Newtonian fluid.			      *
 *                                                                            *
 *                                                                            *
 * -------------------------------------------------------------------------- */

// Last modified: Sat  7 Feb 10:19:05 2015

/* Program Description:
 *
 * This program is written to work with a python setup program. The setup
 * program will write a series of files containing matrix operators of all
 * Fourier modes in the problem. These will then be imported and this program
 * will perform the timestepping using FFT's for the products and my own
 * functions to perform derivatives. Every so often I want to be able to save
 * the state of the fluid, this will mean outputting the current field into a
 * data file. Also I would like to output several properties of the fluid at
 * this point, such as energy etc.
 * 
 * Functions required:
 *
 * dy - returns y derivative of field
 *
 * dx - returns x derivative of a field
 *
 * to_physical - transforms from fully spectral to real space on the GL +
 *		 uniform grid
 *
 * to_spectral - transforms from physical space to fully spectral Chebyshev +
 *		 Fourier space.
 *
 * load_operators - loads the spectral operators from a text file generated in
 *		    python.
 *
 * save_state - saves the flow at the current time to a text file
 *
 * load_state - load the flow from a previous time from a text file.
 *
 * Plenty of other functions would be useful, but these are the essential ones.
 *
 * Unit Testing:
 *
 * Testing will be performed by comparing fields with those generated by python.
 *
 */

// Headers

#include"fields_2D.h"

// Main

int main() 
{
    flow_params params;

    params.N = 20;
    params.M = 40;
    params.Ly = 2.;
    params.kx = 1.31;
    params.Re = 400;
    params.Wi = 1e-05;
    params.beta = 1.0;
    params.dealiasing = 1;

    if (params.dealiasing)
    {
	params.Nf = 3*params.N/2;
	params.Mf = 3*params.M/2;
    } else
    {
	params.Nf = params.N;
	params.Mf = params.M;
    }

    // Declare variables
    FILE *fpi = NULL;
    //double arr[2][10][10];

    int i;
    int N = params.N;
    int M = params.M;
    int Nf = params.Nf;
    int Mf = params.Mf;
    fftw_complex *arrin, *physout, *derivout, *scratchin, *scratchout, *phystest;
    fftw_complex *specout, *specout2, *scratch;
    fftw_plan phys_plan, spec_plan;
    char infn[20] = "initial.h5";

    int shape[2] = { M*(2*N+1), 0 };
    int shapefft[2] = { (2*Mf-2)*(2*Nf+1), 0 };



    //********************************************************************
    // * Test of npy library for complex 2D arrays
    //int testshape[2] = { M*(2*N+1), M };
    //fftw_complex *data; //[M][2*N+1];
    //malloc_array(&data, M, 2*N+1);
    //data = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    //data[ind(0,0)] = 1.0 + 1.0 * I;
    //data[ind(0,2)] = 1.0 + 1.0 * I;
    //data[ind(1,0)] = 1.0 + 1.0 * I;
    //npy_save_double_complex("npytest.npy", 0, 1, testshape, &data[0]);
    //********************************************************************/

    //dynamically malloc array of complex numbers.
    arrin = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    specout = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    specout2 = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    derivout = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));
    scratch = (fftw_complex*) fftw_malloc(M*(2*N+1) * sizeof(fftw_complex));

    physout = (fftw_complex*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(fftw_complex));
    phystest = (fftw_complex*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(fftw_complex));
    scratchin = (fftw_complex*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(fftw_complex));
    scratchout = (fftw_complex*) fftw_malloc((2*Mf-2)*(2*Nf+1) * sizeof(fftw_complex));

    //Set up some dft plans
    phys_plan = fftw_plan_dft_2d(2*Nf+1, 2*Mf-2,  scratchin, scratchout, FFTW_FORWARD, FFTW_ESTIMATE);
    spec_plan = fftw_plan_dft_2d(2*Nf+1, 2*Mf-2,  scratchin, scratchout, FFTW_FORWARD, FFTW_ESTIMATE);

    // load the initial field from scipy
    // fpi = fopen(infn, "r");
    // load_state(fpi, arrin, params);
    // fclose(fpi);

    load_hdf5_state(infn, arrin, params);

    save_hdf5_state("testSpec.h5", arrin, params);
    //for(j=0; j<M; j++)
    //{
    //    printf("%e+%ej \n", creal(arrin[ind(1,j)]), cimag(arrin[ind(1,j)]) );
    //}
    printf("check the index function works correctly\n");
    if ((M*2 + 10) == (ind(2,10)))
    {
	printf("True\n");
    } else
    {
	printf("False\n");
    }
    

    // perform the derivative

    dx(arrin, derivout, params);
    int j;
    
    //npy_save_double_complex("testdx.npy", 0, 1, shape, &derivout[0]);
    save_hdf5_state("testdx.h5", derivout, params);

    dy(arrin, derivout, params);
    //npy_save_double_complex("testdy.npy", 0, 1, shape, &derivout[0]);
    save_hdf5_state("testdy.h5", derivout, params);
    dy(derivout, scratch, params);
    dy(scratch, derivout, params);
    dy(derivout, scratch, params);
    //npy_save_double_complex("testd4y.npy", 0, 1, shape, &scratch[0]);
    save_hdf5_state("testd4y.h5", scratch, params);

    to_physical(arrin, physout, scratchin, scratchout, &phys_plan, params);
    //npy_save_double_complex("testPhysicalT.npy", 0, 1, shapefft, &physout[0]);
    save_hdf5_arr("testPhysicalT.h5", physout, shapefft[0]);

    to_spectral(physout, specout, scratchin, scratchout, &spec_plan, params);
    //npy_save_double_complex("testSpectralT.npy", 0, 1, shape, &specout[0]);
    save_hdf5_state("testSpectralT.h5", specout, params);

    for (i=0; i<2*Nf+1; i++)
    {
	for (j=0; j<Mf; j++)
	{
	    phystest[indfft(i,j)] = cos(i*M_PI/(2.*Nf)) * tanh(j*M_PI/(Mf-1.));
	    // phystest[indfft(i,j)] = i + j;
	    
	}
    }

    to_spectral(phystest, specout2, scratchin, scratchout, &spec_plan, params);
    //npy_save_double_complex("phystest2.npy", 0, 1, shapefft, &phystest[0]);
    save_hdf5_arr("phystest2.h5", phystest, shapefft[0]);

    //npy_save_double_complex("testSpectralT2.npy", 0, 1, shape, &specout2[0]);
    save_hdf5_state("testSpectralT2.h5", specout2, params);

    to_physical(specout2, physout, scratchin, scratchout, &phys_plan, params);
    //npy_save_double_complex("testPhysT4.npy", 0, 1, shapefft, &physout[0]);
    save_hdf5_arr("testPhysT4.h5", physout, shapefft[0]);


    //Test repeated spectral transforms
    int k;
    for (i=0; i<100; i++)
    {
	//for (j=0; j<2*Nf+1; j++)
	//{
	//    for (k=0; k<(2*Mf-2); k++)
	//    {
	//	scratchin[indfft(j,k)] = 0;
	//    }
	//}

	to_physical(arrin, physout, scratchin, scratchout, &phys_plan, params);

	to_spectral(physout, arrin, scratchin, scratchout, &spec_plan, params);
    }

    //npy_save_double_complex("testSpectralTR.npy", 0, 1, shape, &arrin[0]);
    save_hdf5_state("testSpectralTR.h5", arrin, params);

    //garbage collection
    fftw_destroy_plan(phys_plan);
    fftw_destroy_plan(spec_plan);
    fftw_free(arrin);
    fftw_free(physout);
    fftw_free(specout);
    fftw_free(specout2);
    fftw_free(phystest);
    fftw_free(scratchin);
    fftw_free(scratchout);

    return 0;
}
